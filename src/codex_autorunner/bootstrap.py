from pathlib import Path

import yaml

from .core.about_car import (
    ensure_about_car_file_for_repo,
    ensure_ticket_flow_quickstart_file_for_repo,
)
from .core.config import (
    CONFIG_FILENAME,
    DEFAULT_HUB_CONFIG,
    REPO_OVERRIDE_FILENAME,
    ConfigError,
    resolve_hub_config_data,
)
from .core.state import RunnerState, save_state
from .core.ticket_linter_cli import ensure_ticket_linter
from .core.ticket_manager_cli import ensure_ticket_manager
from .core.utils import atomic_write
from .manifest import load_manifest

GITIGNORE_CONTENT = "*"
GENERATED_CONFIG_HEADER = "# GENERATED by CAR - DO NOT EDIT\n"


def sample_todo() -> str:
    return ""


def sample_spec() -> str:
    return ""


def _seed_doc(path: Path, force: bool, content: str) -> None:
    if path.exists() and not force:
        return
    path.write_text(content, encoding="utf-8")


def write_hub_config(hub_root: Path, force: bool = False) -> Path:
    config_path = hub_root / CONFIG_FILENAME
    if config_path.exists() and not force:
        try:
            data = yaml.safe_load(config_path.read_text(encoding="utf-8")) or {}
        except yaml.YAMLError as exc:
            raise ConfigError(
                f"Invalid YAML in existing hub config {config_path}: {exc}. "
                "Back up the file or delete it, or rerun with --force to overwrite."
            ) from exc
        if not isinstance(data, dict):
            raise ConfigError(
                f"Existing hub config {config_path} must be a mapping. "
                "Back up the file or delete it, or rerun with --force to overwrite."
            )
        mode = data.get("mode")
        if mode != "hub":
            raise ConfigError(
                f"Existing config at {config_path} is not a hub config "
                f"(mode: {mode!r}). Move repo overrides into "
                f"{hub_root / REPO_OVERRIDE_FILENAME} or back up and delete the file, "
                "then rerun. Use --force to overwrite it."
            )
        return config_path
    config_path.parent.mkdir(parents=True, exist_ok=True)
    with config_path.open("w", encoding="utf-8") as f:
        f.write(GENERATED_CONFIG_HEADER)
        yaml.safe_dump(
            resolve_hub_config_data(hub_root),
            f,
            sort_keys=False,
        )
    return config_path


def seed_repo_files(
    repo_root: Path, force: bool = False, git_required: bool = True
) -> None:
    """
    Initialize a repository's .codex-autorunner directory with defaults.
    This is used by the CLI init path and hub auto-init discovery.
    Repo config is derived from the hub config; no repo config file is written.
    """
    if git_required and not (repo_root / ".git").exists():
        raise ValueError("Missing .git directory; pass git_required=False to bypass")

    ca_dir = repo_root / ".codex-autorunner"
    ca_dir.mkdir(parents=True, exist_ok=True)

    gitignore_path = ca_dir / ".gitignore"
    if not gitignore_path.exists() or force:
        gitignore_path.write_text(GITIGNORE_CONTENT, encoding="utf-8")

    state_path = ca_dir / "state.sqlite3"
    if not state_path.exists() or force:
        save_state(state_path, RunnerState(None, "idle", None, None, None))

    log_path = ca_dir / "codex-autorunner.log"
    if not log_path.exists() or force:
        log_path.write_text("", encoding="utf-8")

    tickets_dir = ca_dir / "tickets"
    if not tickets_dir.exists() or force:
        tickets_dir.mkdir(parents=True, exist_ok=True)

    workspace_dir = ca_dir / "workspace"
    if not workspace_dir.exists() or force:
        workspace_dir.mkdir(parents=True, exist_ok=True)

    _seed_doc(workspace_dir / "active_context.md", force, sample_todo())
    _seed_doc(workspace_dir / "decisions.md", force, "")
    _seed_doc(workspace_dir / "spec.md", force, sample_spec())

    # Seed an always-available briefing doc for interactive Codex sessions.
    ensure_about_car_file_for_repo(
        repo_root,
        doc_paths={
            "active_context": workspace_dir / "active_context.md",
            "decisions": workspace_dir / "decisions.md",
            "spec": workspace_dir / "spec.md",
        },
        force=force,
    )
    ensure_ticket_flow_quickstart_file_for_repo(repo_root, force=force)
    ensure_ticket_linter(repo_root, force=force)
    ensure_ticket_manager(repo_root, force=force)


def ensure_pma_docs(hub_root: Path, force: bool = False) -> None:
    ca_dir = hub_root / ".codex-autorunner"
    pma_dir = ca_dir / "pma"
    pma_dir.mkdir(parents=True, exist_ok=True)
    _seed_doc(pma_dir / "prompt.md", force, pma_prompt_content())
    _seed_doc(pma_dir / "ABOUT_CAR.md", force, pma_about_content())
    _seed_doc(pma_dir / "AGENTS.md", force, pma_agents_content())
    _seed_doc(pma_dir / "active_context.md", force, pma_active_context_content())
    _seed_doc(pma_dir / "context_log.md", force, pma_context_log_content())


def seed_hub_files(hub_root: Path, force: bool = False) -> None:
    """
    Initialize a hub workspace with defaults and a manifest.
    """
    ca_dir = hub_root / ".codex-autorunner"
    ca_dir.mkdir(parents=True, exist_ok=True)

    gitignore_path = ca_dir / ".gitignore"
    if not gitignore_path.exists() or force:
        gitignore_path.write_text(GITIGNORE_CONTENT, encoding="utf-8")

    write_hub_config(hub_root, force=force)

    ensure_pma_docs(hub_root, force=force)

    manifest_path = hub_root / DEFAULT_HUB_CONFIG["hub"]["manifest"]
    load_manifest(manifest_path, hub_root)

    hub_state_path = ca_dir / "hub_state.json"
    if not hub_state_path.exists() or force:
        atomic_write(
            hub_state_path,
            '{\n  "last_scan_at": null,\n  "repos": []\n}\n',
        )


def pma_prompt_content() -> str:
    return """# Project Management Agent (PMA)

You are the hub-level Project Management Agent (PMA), the user's primary interface for coordinating work across repos.

## Role

You are an **abstraction layer, not an executor**. Coordinate tickets and flows across multiple repos by delegating to repo agents.

## Guidance

- Use CAR-native artifacts (tickets, ticket_flow, dispatch, PMA inbox/outbox).
- Ask questions when requirements are ambiguous; keep updates concise.
- Treat this prompt as code: keep it short and stable.
- See `.codex-autorunner/pma/ABOUT_CAR.md` for operational how-to.

## PMA durable workspace

Prefer writing durable guidance and recurring best-practices to `.codex-autorunner/pma/AGENTS.md`.
Keep short-lived working context in `.codex-autorunner/pma/active_context.md` and prune it when it grows.
When pruning, append the prior context to `.codex-autorunner/pma/context_log.md` with a timestamp.
"""


def pma_notes_content() -> str:
    return """# PMA Operations Guide

## Tickets (create/modify)

- Tickets live per repo at `<repo>/.codex-autorunner/tickets/`.
- Create or edit `TICKET-###*.md` files directly; keep diffs small and single-purpose.
- Set `done: true` in the ticket frontmatter only when the ticket is complete.

## Ticket flow (start/resume)

- Bootstrap (creates TICKET-001 if missing):
  `car flow ticket_flow bootstrap --repo <path>`
- Start/resume:
  `car flow ticket_flow start --repo <path>`
  `car flow ticket_flow resume --repo <path> [--run-id <uuid>]`
- Status/stop:
  `car flow ticket_flow status --repo <path> [--run-id <uuid>]`
  `car flow ticket_flow stop --repo <path> [--run-id <uuid>]`
- See `<repo>/.codex-autorunner/TICKET_FLOW_QUICKSTART.md` for CLI entrypoints + gotchas.

## Dispatch pauses (handle)

- Paused runs appear in the hub inbox snapshot with `repo_id`, `run_id`, and `open_url`.
- Read the latest dispatch, respond to the user, then resume the run.
- Dispatch history lives under:
  `<repo>/.codex-autorunner/runs/<run_id>/dispatch_history/####/DISPATCH.md`

## PMA file handoff

- User uploads arrive in `.codex-autorunner/pma/inbox/`.
- Send user-facing files by writing to `.codex-autorunner/pma/outbox/`.
"""


def pma_about_content() -> str:
    return pma_notes_content()


def pma_agents_content() -> str:
    return """# PMA AGENTS (durable guidance + defaults)

This document is jointly maintained by the user and PMA.

## What belongs here

- Durable best-practices you want PMA to apply repeatedly ("defaults").
- Stable preferences (how to structure tickets, review habits, PR conventions).
- Template shortcuts / references that PMA should re-use.

## What does NOT belong here

- Temporary work-in-progress details (put those in `active_context.md`).
- Long transcripts.

## Template shortcuts (optional)

- Add references to frequently used ticket templates here (repo/path/ref) and when to apply them.

## Defaults (examples)

- After implementation work, add a final review ticket, then a ticket to open a PR.
"""


def pma_active_context_content() -> str:
    return """# PMA active context (short-lived)

Use this file for the current working set: active projects, open questions, links, and immediate next steps.

Pruning guidance:
- Keep this file compact (prefer bullet points).
- When it grows too large, summarize older items and move durable guidance to `AGENTS.md`.
- Before a major prune, append a timestamped snapshot to `context_log.md`.
"""


def pma_context_log_content() -> str:
    return """# PMA context log (append-only)

This file is an append-only history of past `active_context.md` snapshots.

- Add a new section with an ISO timestamp when you perform a major prune.
- Keep entries concise; the goal is searchability and historical recall.
"""
